{"version":3,"sources":["webpack:///webpack/bootstrap","webpack:///../src/client/index.js","webpack:///./handler.js","webpack:///external \"axios\"","webpack:///external \"crypto\"","webpack:///external \"fs\"","webpack:///external \"stream-chat\""],"names":["LayerChat","require","crypto","STREAM_CHAT_TYPE","getUUIDFromURL","url","parts","split","length","getStreamClient","process","env","STREAM_API_KEY","Error","STREAM_API_SECRET","client","StreamChat","convertUser","data","id","message","sender","user_id","convertPartToAttachment","part","t","mime_type","attachment","Object","assign","JSON","parse","body","indexOf","type","thumb_url","convertMessage","user","messageUUID","text","attachments","append","streamMessage","convertChannel","conversationURL","conversation","conversationUUID","l","LayerClientFromEnv","streamChannel","metadata","created_at","updated_at","layer_conversation_id","sync_source","members","participants","p","push","layer","event","signature","headers","WEBHOOK_SECRET","console","log","hmac","createHmac","update","correctSignature","digest","statusCode","stringify","error","channel","chatClient","created_by","name","create","sendMessage","verify","queryStringParameters","verification_challenge"],"mappings":";AAAA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,kDAA0C,gCAAgC;AAC1E;AACA;;AAEA;AACA;AACA;AACA,gEAAwD,kBAAkB;AAC1E;AACA,yDAAiD,cAAc;AAC/D;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iDAAyC,iCAAiC;AAC1E,wHAAgH,mBAAmB,EAAE;AACrI;AACA;;AAEA;AACA;AACA;AACA,mCAA2B,0BAA0B,EAAE;AACvD,yCAAiC,eAAe;AAChD;AACA;AACA;;AAEA;AACA,8DAAsD,+DAA+D;;AAErH;AACA;;;AAGA;AACA;;;;;;;;;;;;AClFA,cAAc,mBAAO,CAAC,oBAAO;AAC7B,WAAW,mBAAO,CAAC,cAAI;;AAEvB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;;AAEA;AACA,YAAY,aAAa,aAAa,aAAa;AACnD;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,+CAA+C;AAC/C;AACA;;AAEA;AACA;AACA,wDAAwD;AACxD;AACA;;AAEA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;;AAEA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,sDAAsD,iBAAiB;AACvE,gBAAgB;AAChB;;AAEA;AACA;;AAEA;AACA,8CAA8C,YAAY;AAC1D;;AAEA;AACA;;AAEA;AACA;AACA,0CAA0C,iBAAiB;AAC3D;AACA;;AAEA;AACA;;AAEA;AACA;AACA,wCAAwC;;AAExC;AACA;;AAEA;AACA;AACA,yCAAyC;;AAEzC;AACA;;AAEA;AACA;AACA;AACA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","file":"handler.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = \"./handler.js\");\n","const axios = require('axios');\nconst fs = require('fs');\n\n/**\n * A subset of Layer's API functionality, aimed to help you export data from Layer\n */\nclass LayerChat {\n\tconstructor(appUUID, token) {\n\t\tthis.appUUID = appUUID;\n\t\tthis.token = token;\n\n\t\tthis.baseURL = 'https://api.layer.com';\n\t}\n\n\t/**\n\t * Small wrapper, returns the response data or raises an error\n\t */\n\tasync _handleResponse(responsePromise) {\n\t\ttry {\n\t\t\tconst response = await responsePromise;\n\t\t\treturn response.data;\n\t\t} catch (e) {\n\t\t\tconsole.log('error', e.response.data);\n\t\t\tthrow e;\n\t\t}\n\t};\n\n\t_getAppPath() {\n\t\treturn `${this.baseURL}` + `/apps/${this.appUUID}`;\n\t}\n\n\t_defaultHeaders() {\n\t\tconst headers = {};\n\t\theaders['Content-Type'] = 'application/json';\n\t\theaders.Authorization = 'Bearer ' + this.token;\n\t\treturn headers;\n\t};\n\n\t_serverHeaders() {\n\t\tconst headers = this._defaultHeaders();\n\t\theaders.Accept = 'application/vnd.layer+json; version=3.0';\n\t\treturn headers;\n\t};\n\n\t_webHookHeaders() {\n\t\tconst headers = this._defaultHeaders();\n\t\theaders.Accept = 'application/vnd.layer.webhooks+json; version=3.0';\n\t\treturn headers;\n\t};\n\n\tasync post(path, data, headers) {\n\t\tif (headers === undefined) {\n\t\t\theaders = this._serverHeaders();\n\t\t}\n\t\tconst config = { headers };\n\t\tconst responsePromise = axios.post(path, data, config);\n\t\treturn this._handleResponse(responsePromise);\n\t}\n\n\tasync put(path, data) {\n\t\tconst headers = this._serverHeaders();\n\t\tconst config = { headers };\n\t\tconst responsePromise = axios.put(path, data, config);\n\t\treturn this._handleResponse(responsePromise);\n\t}\n\n\tasync get(path, params, headers) {\n\t\tif (headers === undefined) {\n\t\t\theaders = this._serverHeaders();\n\t\t}\n\t\tconst config = { headers };\n\t\tconfig.params = params;\n\t\tconst responsePromise = axios.get(path, config);\n\t\treturn this._handleResponse(responsePromise);\n\t}\n\n\tasync createConversation(data) {\n\t\tconst path = this._getAppPath() + '/conversations';\n\t\tconst result = await this.post(path, data);\n\n\t\treturn result;\n\t}\n\n\tasync conversation(conversationUUID) {\n\t\tconst path = this._getAppPath() + `/conversations/${conversationUUID}`;\n\t\tconst data = {app_uuid: this.appUUID}\n\t\tconst result = await this.get(path, data);\n\n\t\treturn result;\n\t}\n\n\tasync createIdentity(data) {\n\t\tconst path = this._getAppPath() + `/users/${data.userID}/identity`;\n\t\tconst result = await this.post(path, data);\n\n\t\treturn result;\n\t}\n\n\tasync sendMessage(conversationUUID, data) {\n\t\tconst path =\n\t\t\tthis._getAppPath() + `/conversations/${conversationUUID}/messages`;\n\t\tconsole.log('path', path, data);\n\t\tconst result = await this.post(path, data);\n\n\t\treturn result;\n\t}\n\n\tasync exports() {\n\t\tconst path = this._getAppPath() + '/exports';\n\t\tconst result = await this.get(path, {});\n\n\t\treturn result;\n\t}\n\n\tasync createExport() {\n\t\tconst path = this._getAppPath() + '/exports';\n\t\tconst result = await this.post(path, {});\n\n\t\treturn result;\n\t}\n\n\tasync registerPublicKey(publicKey) {\n\t\t// TODO https://docs.layer.com/reference/server_api/data.out#register-public-key\n\t\tconst path = this._getAppPath() + '/export_security';\n\t\tconst result = await this.put(path, { public_key: publicKey });\n\n\t\treturn result;\n\t}\n\n\tasync registerWebhook(data) {\n\t\t// https://docs.layer.com/reference/webhooks/rest.out#register\n\t\tconst headers = this._webHookHeaders();\n\t\t//data['app_uuid'] = this.appUUID;\n\t\tconst path = this._getAppPath() + '/webhooks';\n\t\tconst result = await this.post(path, data, headers);\n\n\t\treturn result;\n\t}\n\n\tasync webhooks() {\n\t\tconst headers = this._webHookHeaders();\n\t\tconst path = this._getAppPath() + '/webhooks';\n\t\tconst result = await this.get(path, {}, headers);\n\n\t\treturn result;\n\t}\n\n\tasync exportStatus(exportID) {\n\t\tconst path = this._getAppPath() + `/exports/${exportID}/status`;\n\t\tconst result = await this.get(path, {});\n\n\t\treturn result;\n\t}\n}\n\nfunction LayerClientFromEnv() {\n\tif (!process.env.LAYER_APP_ID) {\n\t\tthrow Error(`The LAYER_APP_ID environment variable is missing`);\n\t}\n\tif (!process.env.LAYER_TOKEN) {\n\t\tthrow Error(`The LAYER_TOKEN environment variable is missing`);\n\t}\n\n\tconst l = new LayerChat(process.env.LAYER_APP_ID, process.env.LAYER_TOKEN);\n\treturn l;\n}\n\nmodule.exports = { Client: LayerChat, LayerClientFromEnv: LayerClientFromEnv };\n","import { StreamChat } from 'stream-chat';\nimport axios from 'axios';\nconst LayerChat = require('../src/client');\nconst crypto = require('crypto');\n\nconst STREAM_CHAT_TYPE = 'messaging';\n\nfunction getUUIDFromURL(url) {\n    const parts = url.split('/');\n    if (parts.length) {\n        return parts[parts.length - 1];\n    }\n}\n\n/**\n * getStreamClient - returns the Stream Chat client\n *\n * @returns {object}  Stream chat client\n */\nfunction getStreamClient() {\n    if (!process.env.STREAM_API_KEY) {\n        throw Error(`Environment variable STREAM_API_KEY is not defined`);\n    }\n    if (!process.env.STREAM_API_SECRET) {\n        throw Error(`Environment variable STREAM_API_SECRET is not defined`);\n    }\n\n    const client = new StreamChat(\n        process.env.STREAM_API_KEY,\n        process.env.STREAM_API_SECRET\n    );\n\n    return client;\n}\n\nfunction convertUser(data) {\n    // TODO: handle the extra fields...\n    return { id: data.message.sender.user_id };\n}\n\nfunction convertPartToAttachment(part) {\n    // TODO: Support Content system\n    // Lot of flexibility in terms of message types...\n    // https://docs.layer.com/xdk/webxdk/messages#message-parts\n    // https://docs.layer.com/reference/webhooks/message.obj#messages\n    const t = part.mime_type;\n    let attachment = Object.assign({}, part);\n    if (t === 'application/json') {\n        attachment = Object.assign(attachment, JSON.parse(part.body));\n    } else if (t.indexOf('image') !== -1) {\n        attachment.type = 'image';\n        attachment.thumb_url = part.url;\n    }\n\n    return attachment;\n}\n\nfunction convertMessage(data, user) {\n    // TODO: Verify we handle all edge cases with message parts\n    const parts = data.message.parts;\n    const message = data.message;\n    const messageUUID = getUUIDFromURL(message.id);\n\n    let text = '';\n    if (parts[0].mime_type === 'text/plain') {\n        text = parts[0].body;\n    }\n    const attachments = [];\n    for (const part of parts) {\n        if (part.mime_type !== 'text/plain') {\n            attachments.append(convertPartToAttachment(part));\n        }\n    }\n\n    const streamMessage = {\n        user,\n        text,\n        //created_at: message.sent_at,\n        id: messageUUID,\n        attachments,\n    };\n\n    return streamMessage;\n}\nasync function convertChannel(data) {\n    // TODO: handle distinct..\n    // https://docs.layer.com/sdk/web/conversations#distinct-conversations\n    //\n    // TODO: handle createdBy\n    const conversationURL = data.message.conversation.id;\n    const conversationUUID = conversationURL.split('/')[\n        conversationURL.split('/').length - 1\n    ];\n    const l = LayerChat.LayerClientFromEnv();\n    const conversation = await l.conversation(conversationUUID);\n    // channels are pretty similar to conversations...\n    // metadata needs to be imploded\n    // created_at and updated_at are the same\n    // id and chat type are different\n    const streamChannel = conversation.metadata || {};\n    streamChannel.type = STREAM_CHAT_TYPE;\n    streamChannel.id = conversationUUID;\n    streamChannel.created_at = conversation.created_at;\n    streamChannel.updated_at = conversation.updated_at;\n    streamChannel.layer_conversation_id = conversationUUID;\n    streamChannel.sync_source = 'webhook';\n    const members = [];\n\n    for (const p of conversation.participants) {\n        members.push(p.user_id);\n    }\n    streamChannel.members = members;\n\n    return streamChannel;\n}\n\nexport const layer = async event => {\n    const data = JSON.parse(event.body);\n\n    // - validate the payload\n    // - parse the layer webhook event\n    // - figure out the corresponding stream channel\n    // - convert the message\n    // - write the message to Stream\n\n    // Validate the layer webhook data\n    // https://docs.layer.com/reference/webhooks/payloads#validating-payload-integrity\n    const signature = event.headers['layer-webhook-signature']\n    if (!process.env.WEBHOOK_SECRET) {\n      console.log(\"WEBHOOK secret is not defined\")\n    }\n    const hmac = crypto.createHmac('sha1', process.env.WEBHOOK_SECRET);\n    hmac.update(event.body);\n    const correctSignature = hmac.digest('hex');\n    if (signature !== correctSignature) {\n      return {\n          statusCode: 200,\n          headers: {\n              'Access-Control-Allow-Origin': '*',\n          },\n          body: JSON.stringify({\n              error: 'Signature was not correct, check your webhook secret and verify the serverless handler uses the same',\n          }),\n      };\n    }\n\n    if (data.event.type !== 'Message.created') {\n        // skip\n        return {\n            statusCode: 200,\n            headers: {\n                'Access-Control-Allow-Origin': '*',\n            },\n            body: JSON.stringify({\n                error: 'not able to handle events of this type...',\n            }),\n        };\n    }\n\n    // convert the webhook data\n    const channel = await convertChannel(data);\n    const user = convertUser(data);\n    const message = convertMessage(data, user);\n    console.log('converted channel', channel);\n    console.log('converted user', user);\n    console.log('converted message', message);\n    // lookup the conversation...\n    const chatClient = getStreamClient();\n    const streamChannel = chatClient.channel(channel.type, channel.id, {created_by: {id: 'layer_sync', name: 'layer sync'}});\n    await streamChannel.create();\n    await streamChannel.sendMessage(message);\n\n    return {\n        statusCode: 200,\n        headers: {\n            'Access-Control-Allow-Origin': '*',\n        },\n        body: JSON.stringify({ data }),\n    };\n};\n\nexport const verify = async event =>\n    // return the verification_challenge param\n    ({\n        statusCode: 200,\n        headers: {\n            'Access-Control-Allow-Origin': '*',\n        },\n        body: event.queryStringParameters.verification_challenge,\n    });\n","module.exports = require(\"axios\");","module.exports = require(\"crypto\");","module.exports = require(\"fs\");","module.exports = require(\"stream-chat\");"],"sourceRoot":""}